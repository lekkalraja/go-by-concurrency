## Channels

###### How to get value computed by goroutine into main routine ?

    ```go
        package main

        import "fmt"

        func main() {
	        /*sum :=*/go func(num1, num2 int) /*int*/ {
                            sum := num1 + num2
                            fmt.Printf("Calculated sum for %d, %d : %d \n", num1, num2, sum)
                            // return sum // ERROR : Should not return from go routine
	                     }(2, 4)
        }

    ```
* Here we `can not return` value from go-routine
* `Answer is **channel**`

### Channel
* channels can be used to communicate data between goroutines
* It also helps to synchronise goroutines
* channels are typed and thread-safe

    ```go
        // Declaring and Initializing the channel

        var ch chan T // Declaring channel with default i.e. nil of type T
        ch = make(chan T) // Initializing/creating channel i.e. allocating memory in the heap and giving reference to `ch` variable

        // (OR)
        ch := make(chan T) // Declaring and initializing chan with `:=` operator
    ```

##### Channel Operations
1.  `<-` (arrow) operator is used for sending and receiving the value from channel
2.  The `<-` (arrow) indicates the direction of data flow

    ```go
        ch := make(chan string)

        ch <- "Sending data" // sending data to channel

        close(ch) // closing channel

        v := <- ch // receiving data from channel
    ```

###### Channels are blocking

* `ch <- value` :  `sender goroutine will wait for a receiver to be ready`
* `value := <- ch` : `receiver goroutine will wait for a value to be sent`
* It is `responsibilit of channel` to make the `goroutine runnable again` once it has data.

3. `close(ch)` closing channel i.e. no more values to be sent

    ```go
        ch := make(chan string)

        go func(elements int) {
            defer close(ch) // closing channel
            for i := 0; i < elements; i++ {
                ch <- i
            }
        }(5)

    ```

* channel receive operation will give 2 values i.e.

    ```go
        ch := make(chan string)
        ch <- 4

        value, ok := <- ch

        // value is the data sent to channel
        // ok = true , when value generated by a write
        // ok = false, when value generated by a close
    ```

##### `range` operator on channel

* Iterate over values received from a channel
* `Loop automatically breaks, when a channel is closed`
* `range` does not return the second boolean value i.e. `ok`

    ```go
        ch := make(chan string)

         go func(elements int) {
            defer close(ch)
            for i := 0; i < elements; i++ {
                ch <- i
            }
        }(5)

        for value := range ch {
            fmt.Println("Received vlaue", value)
        }
    ```

###### Unbuffered Channels

* Unbuffered channels are `Synchronous`

![un_buffered_channel](images/unbuffered_channel.png)

    ```go
        ch := make(chan Type)
    ```

###### Buffered Channels
* Buffered Channels are `Asynchronous`
* capacity given to channels and these type of channel holds data in-memory FIFO queue (sudog struct)

![buffered_channel](images/buffered_channel.png)

    ```go
        ch := make(chan Type, capacity)
    ```

##### Channel Direction

* When using channels as function parameters, you can specify if a channel is meant to `only send` or `only receive` or `both` values
* This specificity increases the `type-safety` of the program.

    ```go
        // send only channel
        func write(ch chan<- string) {
            ch <- "Writing Data"
	        /* value := <-ch // ERROR: Invalid Operation: cannot receivefor send-only channel
	           fmt.Println(value) */
        }

        // read only chanel
        func read(ch <-chan string) string {
        	value, ok := <-ch
	        // ch <- "Invalid Operation" // Error : Invalid operation: cannot send to receive-only type <-chan string
            if ok {
                return value
            }
            return "Channel is Closed"
        }

        // write & read channel
        func writeAndRead(ch chan string){}
    ```

###### Default value - Channels
* Default value for channels : `nil`
* reading/writing to a `nil channel will block forever (deadlock)`
* Closing nil channel will panic

    ```go
        package main

        func main() {
            var ch chan string

            /*
                fatal error: all goroutines are asleep - deadlock!

                goroutine 1 [chan send (nil chan)]:
            */
            ch <- "data"

            /*
                fatal error: all goroutines are asleep - deadlock!

                goroutine 1 [chan receive (nil chan)]:
            */
            <-ch

            /*
                panic: close of nil channel

                goroutine 1 [running]:
            */
            close(ch)

            ch = make(chan string)
            close(ch)
            /*
                panic: close of closed channel

                goroutine 1 [running]:
            */
            close(ch)
        }
    ```

* To avoid all this,`Ensure the channels are initialized first.`

###### Ownership - Channels
* Owner of channel (goroutine) is responsible for
  * Instantiaing the channel
  * writing data to channel
  * closing the channel

* channel `utilizers` only have a `read-only` view into the channel.
* So `Ownership of channels avoids`
  * Deadlocking by writing to a nil channel
  * closing a nil channel
  * writing to a closed channel
  * closing a channel more than once

## Deep-Dive (How internally channel's will manage to work)

* `hchan` struct represents channel.

    ```go
     // https://golang.org/src/runtime/chan.go - for more details

     type hchan struct {
        qcount   uint           // total data in the queue
        dataqsiz uint           // size of the circular queue
        buf      unsafe.Pointer // points to an array of dataqsiz elements
        elemsize uint16
        closed   uint32
        elemtype *_type // element type
        sendx    uint   // send index
        recvx    uint   // receive index
        recvq    waitq  // list of recv waiters
        sendq    waitq  // list of send waiters

        // lock protects all fields in hchan, as well as several
        // fields in sudogs blocked on this channel.
        //
        // Do not change another G's status while holding this lock
        // (in particular, do not ready a G), as this can deadlock
        // with stack shrinking.
        lock mutex
    }

    type waitq struct {
        first *sudog
        last  *sudog
    }

    // https://golang.org/src/runtime/runtime2.go

    type sudog struct {
        // The following fields are protected by the hchan.lock of the
        // channel this sudog is blocking on. shrinkstack depends on
        // this for sudogs involved in channel ops.

        g *g

        next *sudog
        prev *sudog
        elem unsafe.Pointer // data element (may point to stack)
        .....
        c        *hchan // channel
    }
    ```

* lets create a channel : `ch := make(chan int, 3)`
  *   `hchan` struct is allocted in heap.
  *   `make()` returns a pointer to it
  *   Sinche `ch` is pointer it can be between functions for send and receive

![channel_ds](images/chan_ds.png)

##### Send and Receive buffered channels

    ```go
        ch := make(chan int, 3)

        // G1 - goroutine (write goroutine)
        func G1(ch chan<- int) {
            for _, v := range []int{1, 2, 3, 4} {
                ch <- v
            }
        }

        // G2 - goroutine (read goroutine)
        func G2(ch <-chan int) {
            for v := range ch {
                fmt.Println(v)
            }
        }
    ```

* when go-runtime executes `ch := make(chan int, 3)`,  Internally it will allocate memory in heap like below

![send_recv_1](images/send_recv_1.png)

## Scenario-1 : G1 - Executes first
###    `ch <- v`

![chan creation instruction](images/g1_instruction_executed.png)
![g1_acquried_lock](images/g1_acquired_loc.png)
![g1_enqueing_data](images/g1_enqueing_data.png)
![g1_releasing_lock](images/g1_release_lock.png)

* And then G2 will get control

![g2_acquired_lock](images/g2_acquire_lock.png)
![g2_dequeue_data](images/g2_dequeue_data.png)
![g2_copy_to_var](images/g2_copy_data_to_variable.png)
![g2_increment_counter](images/g2_increment_receiver_index_counter.png)
![g2_release_lock](images/g2_release_lock.png)

#### Note:
* There is no memory share between goroutines
* Goroutines copy elements into and from `hchan`
* `hchan` is protected by `mutex lock`

###### Do not communicate by sharing memory; instead, share memory by communicating

## Buffer Full Scenario

* When channel buffer is full and a goroutine tries to send value.
* Sender goroutine gets blocked, it is parked on sendQ
* Data will be saved in the elem filed of the `sudog` structure
* Enqueues the data from elem field to the buffer by `G2`
* Pops the goroutine in sendq, and puts it into runnable state by `G2`

![buffered-1](images/buffered_1.png)
![buffered-2](images/buffered-2.png)
![buffered-3](images/buffered-3.png)
![buffered-4](images/buffered-4.png)
![buffered-5](images/buffered-5.png)
![buffered-6](images/buffered-6.png)
![buffered-7](images/buffered-7.png)
![buffered-8](images/buffered-8.png)
![buffered-9](images/buffered-9.png)
![buffered-10](images/buffered-10.png)
![buffered-11](images/buffered-11.png)

## Buffer Empty Scenario

* When goroutine calls receive on empty buffer
* Goroutine is blocked, it is parked into recvq
* elem field of the `sudog` structure holds the reference to the stack variable of receiver goroutine
* when sender comes along, sender finds the goroutine in recvq
* Sender copies the data, into the stack variable, on the receiver goroutine directly
* pops the goroutine in recvq, and puts it into runnable state.

![empty_buffered_channel_1](images/empty_channel_1.png)
![empty_buffered_channel_2](images/empty_channel_2.png)
![empty_buffered_channel_3](images/empty_channel_3.png)
![empty_buffered_channel_4](images/empty_channel_4.png)
![empty_buffered_channel_5](images/empty_channel_5.png)
![empty_buffered_channel_6](images/empty_channel_6.png)
![empty_buffered_channel_7](images/empty_channel_7.png)
![empty_buffered_channel_8](images/empty_channel_8.png)
![empty_buffered_channel_9](images/empty_channel_9.png)

## Send and Receive Unbuffered channels

* When sender goroutine wants to send values
* if there is corresponding receiver waiting in recvq.
* Sender will write the value directly into the receiver goroutine stack variable
* Sender goroutine puts the receiver goroutine back to runnable state.
* If there is no receiver goroutine in recvq
* Sender gets parked into sendq
* Data is saved in elem field in sudog struct
* Receiver comes and copies the data
* Puts the sender to runnable state again.

#### Receive on unbuffered channel
* Receiver goroutine wants to receive value
* if it find a goroutine in waiting in sendq
* Receiver copies the value in elem field to its variable
* puts the sender goroutine to runnable state
* If there was no sender goroutine in sendq
* Receiver gets parked into recvq
* Reference to variable is saved in elem field in sudog struct
* sender comes and copies the data directly to receiver stack variable.
* puts the receiver to runnable state.

### Summary
* Channels are used to communicate data between Goroutines
* In unbuffered channels send and receive are synchronous
* Buffered channels we can specify the capacity of buffer
* Channel direction used in funciton parameter increases type safety
* Establishing the ownership of channel avoids deadlocks and panics

* `hchan` struct represents channel
* It contains circular ring buffer and mutext lock
* goroutines that gets blocked on send or recv are parked in sendq or recvq
* Go Scheduler moves the blocked goroutines, out of OS thread
* Once channel operation is complete, goroutine is moved back to local run queue.